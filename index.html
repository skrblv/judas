<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Sanira — Hair + Parallax (Сильная анимация)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #fff;
    }
    #app {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      background: #000;
    }
    #loader {
      position: fixed; inset: 0; display: grid; place-items: center;
      background: #000; z-index: 20; transition: opacity .4s ease;
    }
    #loader.hidden { opacity: 0; pointer-events: none; }
  </style>
</head>
<body>
  
  <video id="baseVideo" preload="auto" playsinline muted loop style="display:none">
    <source src="./sanira.mp4" type="video/mp4" />
  </video>
  
  <!-- Тег <audio> убран из HTML, чтобы избежать ошибок загрузки -->

  <div id="app"></div>
  <div id="loader">Загрузка…</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    
    
    const app = document.getElementById('app');
    const loaderEl = document.getElementById('loader');
    const videoEl = document.getElementById('baseVideo');
    
    // ИЗМЕНЕНИЕ №1: Создаем аудио прямо в JS для надежности
    const audioEl = new Audio('./judas.mp3');
    audioEl.loop = true;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    app.appendChild(renderer.domElement);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.75));
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    let vw = window.innerWidth, vh = window.innerHeight;
    const camera = new THREE.OrthographicCamera(-vw/2, vw/2, vh/2, -vh/2, -1000, 1000);
    camera.position.set(0, 0, 10);

    const root = new THREE.Group();
    scene.add(root);

    const LAYER = { BACK: -10, VIDEO: 0, HAIR: 10 };

    function resizeRenderer() {
      vw = window.innerWidth;
      vh = window.innerHeight;
      renderer.setSize(vw, vh, false);
      camera.left = -vw/2;
      camera.right = vw/2;
      camera.top = vh/2;
      camera.bottom = -vh/2;
      camera.updateProjectionMatrix();
      fitCover(backgroundMesh, bgTex.image ? bgTex.image.width : 1920, bgTex.image ? bgTex.image.height : 1080, -1);
  fitCover(videoMesh, videoEl.videoWidth || 1920, videoEl.videoHeight || 1080, 1, 'contain');
      positionHair();
    }

// Универсальная функция: режим 'cover' (по умолчанию) или 'contain' (влезает полностью)
function fitCover(mesh, texW, texH, zIndex = 0, mode = 'cover', scale = 1) {
  if (!mesh || !texW || !texH) return;
  const viewW = vw;
  const viewH = vh;
  const viewAR = viewW / viewH;
  const texAR = texW / texH;
  let width, height;
  if (mode === 'contain') {
    if (texAR > viewAR) {
      width = viewW * scale;
      height = width / texAR;
    } else {
      height = viewH * scale;
      width = height * texAR;
    }
  } else { // cover
    if (texAR > viewAR) {
      height = viewH * scale;
      width = height * texAR;
    } else {
      width = viewW * scale;
      height = width / texAR;
    }
  }
  mesh.scale.set(width, height, 1);
  mesh.position.set(0, 0, zIndex); // всегда по центру!
}

    function hideLoader() {
      loaderEl.classList.add('hidden');
      setTimeout(() => loaderEl.remove(), 500);

      // Надежный способ запустить музыку
      const playPromise = audioEl.play();
      if (playPromise !== undefined) {
        playPromise.catch(error => {
          console.warn("Autoplay был заблокирован браузером. Музыка начнется после первого клика.");
        });
      }

      function enableAudio() {
        audioEl.play().catch(() => {});
        window.removeEventListener('click', enableAudio);
        window.removeEventListener('touchstart', enableAudio);
      }
      window.addEventListener('click', enableAudio);
      window.addEventListener('touchstart', enableAudio);
    }

    const texLoader = new THREE.TextureLoader();
    const bgTex = texLoader.load('bg.png', () => {
      bgTex.colorSpace = THREE.SRGBColorSpace;
      resizeRenderer();
    });

    const bgMat = new THREE.MeshBasicMaterial({ map: bgTex, depthTest: false, depthWrite: false });
    const unitPlane = new THREE.PlaneGeometry(1,1);
    const backgroundMesh = new THREE.Mesh(unitPlane, bgMat);
    backgroundMesh.renderOrder = 0;
    root.add(backgroundMesh);

    videoEl.muted = true;
    videoEl.setAttribute('muted', '');
    videoEl.setAttribute('playsinline', '');
    videoEl.play().catch(() => {
      const playOnce = () => videoEl.play().catch(()=>{});
      window.addEventListener('pointerdown', playOnce, { once: true, passive: true });
    });

    const videoTex = new THREE.VideoTexture(videoEl);
    videoTex.colorSpace = THREE.SRGBColorSpace;
    const videoMat = new THREE.MeshBasicMaterial({ map: videoTex, transparent: false, depthTest: false, depthWrite: false });
    const videoMesh = new THREE.Mesh(unitPlane, videoMat);
    videoMesh.renderOrder = 1;
    root.add(videoMesh);

    // Теперь можно задавать размеры для каждого hair-X
    // Управление размерами всех волос одной парой значений
    const HAIR_SIZE = { w: 650, h: 700 };
    const HAIR_SOURCES = [
      { file: 'hair-1.png', anchor: { x: -0.08, y: 0.05 }, size: HAIR_SIZE },
      { file: 'hair-2.png', anchor: { x:  -0.10, y: 0.05 }, size: HAIR_SIZE },
      { file: 'hair-3.png', anchor: { x: -0.15, y: 0.05 }, size: HAIR_SIZE },
      { file: 'hair-4.png', anchor: { x:  -0.05, y: 0.02 }, size: HAIR_SIZE },
      { file: 'hair-5.png', anchor: { x:  0.04, y: 0.08 }, size: HAIR_SIZE },
    ];
    const hairGroup = new THREE.Group();
    hairGroup.renderOrder = 2;
    root.add(hairGroup);
    const hairs = [];


    // Создание волос с BufferGeometry: верх фиксирован, низ волной
    function createHairMesh({ file, anchor, size }, i) {
      const tex = texLoader.load(file, positionHair);
      tex.colorSpace = THREE.SRGBColorSpace;
      // 4 вершины: top-left, top-right, bottom-left, bottom-right
      const w = size.w, h = size.h;
      const geometry = new THREE.BufferGeometry();
      // x, y, z для 4 вершин
      const vertices = new Float32Array([
        -w/2, h/2, 0,   // 0: top left
         w/2, h/2, 0,   // 1: top right
        -w/2, -h/2, 0,  // 2: bottom left
         w/2, -h/2, 0   // 3: bottom right
      ]);
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      // UVs
      const uvs = new Float32Array([
        0, 1, 1, 1, 0, 0, 1, 0
      ]);
      geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
      geometry.setIndex([0,2,1, 1,2,3]);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthTest: false, depthWrite: false });
      const mesh = new THREE.Mesh(geometry, mat);
      mesh.userData = { anchor, base: new THREE.Vector3(), size };
      hairGroup.add(mesh);
      hairs.push(mesh);
      mesh.renderOrder = 3 + i;
      return mesh;
    }

    // Очищаем старые волосы и создаём новые
    while (hairGroup.children.length) hairGroup.remove(hairGroup.children[0]);
    hairs.length = 0;
    HAIR_SOURCES.forEach((src, i) => createHairMesh(src, i));

    // Анимация: верхние вершины фиксированы, низ волной
    function animateHairWind() {
      function updateHairWave() {
        const t = performance.now() / 1000;
        hairs.forEach((mesh, i) => {
          const pos = mesh.geometry.attributes.position;
          const base = mesh.userData;
          const w = base.size.w, h = base.size.h;
          // Верхние точки (0,1) не трогаем
          // Нижние точки (2,3) двигаем по синусоиде
          const ampX = 18, ampY = 22;
          const phase = t * 1.5 + i;
          // X
          pos.setX(2, -w/2 + Math.sin(phase) * ampX);
          pos.setX(3,  w/2 + Math.cos(phase + 0.7) * ampX);
          // Y
          pos.setY(2, -h/2 + Math.cos(phase + 0.3) * ampY);
          pos.setY(3, -h/2 + Math.sin(phase + 0.9) * ampY);
          pos.needsUpdate = true;
        });
        requestAnimationFrame(updateHairWave);
      }
      updateHairWave();
    }

    function positionHair() {
      // Размеры видео для позиционирования, масштаб волос индивидуальный
      const vW = videoMesh.scale.x;
      const vH = videoMesh.scale.y;
      hairs.forEach((mesh) => {
        const size = mesh.userData.size || { w: 650, h: 700 };
        // Для BufferGeometry: пересоздаём вершины
        const pos = mesh.geometry.attributes.position;
        pos.setXYZ(0, -size.w/2, size.h/2, 0); // top left
        pos.setXYZ(1,  size.w/2, size.h/2, 0); // top right
        pos.setXYZ(2, -size.w/2, -size.h/2, 0); // bottom left
        pos.setXYZ(3,  size.w/2, -size.h/2, 0); // bottom right
        pos.needsUpdate = true;
        const px = mesh.userData.anchor.x * vW;
        const py = mesh.userData.anchor.y * vH;
        mesh.position.set(px, py, LAYER.HAIR);
        mesh.userData.base = { x: px, y: py, z: LAYER.HAIR };
      });
    }

    gsap.to(camera, {
      duration: 4.5, repeat: -1, yoyo: true, ease: "sine.inOut",
      zoom: 1.04, onUpdate: () => camera.updateProjectionMatrix()
    });
    gsap.to(root.position, {
      duration: 8, repeat: -1, yoyo: true, ease: "sine.inOut",
      x: "+=8", y: "-=6"
    });
    
    window.addEventListener('resize', resizeRenderer);



    // =======================================================
    // КОД ДЛЯ ПЛАВНОГО ДВИЖЕНИЯ СЦЕНЫ ЗА МЫШЬЮ (ПАРАЛЛАКС)
    // =======================================================
    function onPointerMove(e) {
      // Получаем координаты курсора в формате от -1 до +1
      const pointerX = (e.clientX / window.innerWidth) * 2 - 1;
      const pointerY = -(e.clientY / window.innerHeight) * 2 + 1;
      // Коэффициент силы движения. Можете сделать его больше (например, 25), если хотите, чтобы сцена двигалась сильнее.
      const parallaxFactor = 35;
      // Анимируем всю сцену (root - это группа, где лежат фон, видео и волосы)
      // Она будет плавно двигаться в ПРОТИВОПОЛОЖНУЮ от курсора сторону, создавая эффект глубины.
      gsap.to(root.position, {
        x: -pointerX * parallaxFactor,
        y: -pointerY * parallaxFactor,
        duration: 1.2, // Длительность анимации, делает движение плавным
        ease: "power2.out" // Тип анимации для плавного замедления
      });
    }
    window.addEventListener('mousemove', onPointerMove);

    function render() {
      requestAnimationFrame(render);
      camera.lookAt(0, 0, 0);
      renderer.render(scene, camera);
    }
    render();

    const readinessCheck = setInterval(() => {
        const videoReady = videoEl.readyState >= 2;
        const hairsReady = hairs.every(mesh => mesh.material.map && mesh.material.map.image);
        if (videoReady && hairsReady && bgTex.image) {
            resizeRenderer();
            hideLoader();
            animateHairWind();
            clearInterval(readinessCheck);
        }
    }, 100);

    resizeRenderer();
  </script>
</body>
</html>